# Урок 3. Принципы SOLID

### 1. Спроектировать абстрактный класс «Car» у которого должны быть свойства: марка, модель, цвет, тип кузова, число колёс, тип топлива, тип коробки передач, объём двигателя; методы: движение, обслуживание, переключение передач, включение фар, включение дворников.
Создан абстрактный класс `Car` с заданными в условии параметрами.

### 2. Создать конкретный автомобиль путём наследования класса «Car».
Создан класс `Toyota`.

### 3. Расширить абстрактный класс «Car», добавить метод: подметать улицу. Создать конкретный автомобиль путём наследования класса «Car». Провести проверку принципа SRP.
Следование принципу `SPR` предполагает, что класс должен отвечать только за какую-то одну сущность,
в нашем случае, это абстрактный класс, который имеет базовые характеристики для всех классов наследников.
Добавление предложенного метода нарушит абстрактность базового класса, т.к. функция `подметать улицу` есть только у конкретных машин.

Создадим интерфейс `ISweepingStreet` с методом `подметать улицы` для возможности подключения в конкретные классы.
Подключим этот интерфейс к классу `Toyota`.
### 4. Расширить абстрактный класс «Car», добавить метод: включение противотуманных фар, перевозка груза. Провести проверку принципа OCP.
Добавляем новые методы в абстрактный класс `Car`. 
Это не нарушает принцип `OCP`, т.к. мы не изменяем уже существующий код, а дописываем новый.

Добавленные методы будут доступны во всех классах наследниках.
### 5. Создать конкретный автомобиль путём наследования класса «Car», определить число колёс = 3. Провести проверку принципа LSP.
Создаем класс `Morgan3Wheeler` с тремя колесами.

Принцип `LSP` не нарушается, т.к. все методы родительского класса выполняются.
### 6. Создать конкретный автомобиль путём наследования класса «Car», определить метод «движение» - «полёт». Провести проверку принципа LSP.
Создадим класс `FlyMobil` путём наследования класса `Car`.
Базовых характеристик абстрактного класса для такого типа автомобиля будет недостаточно,
нужно добавлять, как минимум, наличие крыльев в конструктор класса. Это нарушает принцип подстановки,
т.к. мы не сможем создать такой тип, при инициализации базового класса.
### 7. Создать интерфейс «Заправочная станция», создать метод: заправка топливом.
Создаем интерфейс `IGasStation`.
### 8. Имплементировать метод интерфейса «Заправочная станция» в конкретный класс «Car».
Имплементируем метод интерфейса `IGasStation` в класс `Toyota`.
### 9. Добавить в интерфейс «Заправочная станция» методы: протирка лобового стекла, протирка фар, протирка зеркал.
Добавляем в интерфейс `IGasStation` методы : `cleaningLights()`; `cleaningMirrors()`;
`cleaningWindshield()`.
### 10. Имплементировать все методы интерфейса «Заправочная станция» в конкретный класс «Car». Провести проверку принципа ISP. Создать дополнительный/е интерфейсы и имплементировать их в конкретный класс «Car». Провести проверку принципа ISP.
Если мы теперь используем интерфейс `IGasStation` в классе `Toyota`, 
то придется реализовывать все методы этого интерфейса, но у нашего класса может не быть таких возможностей. 
Это нарушает принцип `ISP`. 

Создадим для методов `cleaningLights()`; `cleaningMirrors()`;
`cleaningWindshield()` отдельные интерфейсы, чтобы использовать каждый метод только там, где это необходимо.
### 11. Создать путём наследования класса «Car» два автомобиля: с бензиновым и дизельным двигателями, имплементировать метод «Заправка топливом» интерфейса «Заправочная станция». Реализовать заправку каждого автомобиля подходящим топливом. Провести проверку принципа DIP.
Зададим классу `Toyota` тип топлива `diesel`, а классу `Morgan3Wheeler` - `petrol`.

Имплементировать метод `fueling()` из интерфейса `IGasStation`. В каждом классе переписываем метод под определенный тип топлива.

Принцип `DIP` не нарушается, т.к. работа метода `fueling()` не зависит от конкретного топлива.